[HW 2]

Question 1:
type Vector = [Double]
scale :: Double -> Vector -> Vector
scale x vs = [x*v| v <- vs]
add :: Vector -> Vector -> Vector
add [] [] = []
add (v1:vs1) (v2:vs2) = v1+v2:add vs1 vs2
dot :: Vector -> Vector -> Double
dot [] [] = 0
dot (v1:vs1) (v2:vs2) = v1*v2 + dot vs1 vs2

Question 2:
module ApplyToList where
import BinaryRelation

applyRel :: (Eq k) => k -> (BinaryRelation k v) -> [v]
applyRel key xys = [y | (x,y) <- xys, x==key]	

applyToList :: (Eq k) => [k] -> (BinaryRelation k v) -> [v]
applyToList _ [] = []
applyToList [] _ = []
applyToList [] [] = []
applyToList (key:keys) xys = applyRel key xys ++ applyToList keys xys




[HW 1]
1:
average3 :: (Double, Double, Double) -> Double
average3 (x, y, z) = (x + y + z) / 3

2a: 
5
2b:
legal: 5
illegal: 1, 2, 3, 4, 6
2c:
([3,4,7,5,8],[3,4,7,5,8])


3a:
add10_list_comp :: [Integer]  -> [Integer] 
add10_list_comp (x) = map (+10) x
3b: 
add10_list_rec :: [Integer]  -> [Integer] 
add10_list_rec [] = []
add10_list_rec (x:xs) = [x+10] ++ (add10_list_comp xs)

4:
cubeOdds :: [Integer] -> [Integer]
cubeOdds [] = []
cubeOdds [x] = [x*x*x]
cubeOdds (x:y:xs) = x*x*x : y : cubeOdds xs
